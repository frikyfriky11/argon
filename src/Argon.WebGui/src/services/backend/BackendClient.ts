//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import ServiceBase from "./ServiceBase";import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

import { DateTime, Duration } from "luxon";

export class AccountsClient extends ServiceBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        super();

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("");

    }

    /**
     * Gets a list of Accounts
     * @param request (optional) 
     */
    getList(request: AccountsGetListRequest | undefined, cancelToken?: CancelToken | undefined): Promise<AccountsGetListResponse[]> {
        let url_ = this.baseUrl + "/Accounts?";
        if (request === null)
            throw new Error("The parameter 'request' cannot be null.");
        else if (request !== undefined)
            url_ += "request=" + encodeURIComponent("" + request) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processGetList(_response));
        });
    }

    protected processGetList(response: AxiosResponse): Promise<AccountsGetListResponse[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AccountsGetListResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<AccountsGetListResponse[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AccountsGetListResponse[]>(null as any);
    }

    /**
     * Creates a new Account
     * @param request The Account entity to create
     * @return The id of the newly created Account
     */
    create(request: AccountsCreateRequest, cancelToken?: CancelToken | undefined): Promise<AccountsCreateResponse> {
        let url_ = this.baseUrl + "/Accounts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCreate(_response));
        });
    }

    protected processCreate(response: AxiosResponse): Promise<AccountsCreateResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AccountsCreateResponse.fromJS(resultData200);
            return Promise.resolve<AccountsCreateResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("The supplied Account object did not pass validation checks", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AccountsCreateResponse>(null as any);
    }

    /**
     * Gets an existing Account
     * @param id The id of the Account
     * @return The Account with the specified id
     */
    get(id: string, cancelToken?: CancelToken | undefined): Promise<AccountsGetResponse> {
        let url_ = this.baseUrl + "/Accounts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processGet(_response));
        });
    }

    protected processGet(response: AxiosResponse): Promise<AccountsGetResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AccountsGetResponse.fromJS(resultData200);
            return Promise.resolve<AccountsGetResponse>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A Account with the specified id could not be found", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AccountsGetResponse>(null as any);
    }

    /**
     * Updates an existing Account
     * @param id The id of the Account
     * @param request The Account entity to update
     * @return The Account was correctly updated
     */
    update(id: string, request: AccountsUpdateRequest, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Accounts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUpdate(_response));
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("The supplied Account object did not pass validation checks", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A Account with the specified id could not be found", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Deletes an existing Account
     * @param id The id of the Account
     * @return Nothing
     */
    delete(id: string, cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/Accounts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processDelete(_response));
        });
    }

    protected processDelete(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class TransactionsClient extends ServiceBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        super();

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("");

    }

    /**
     * Gets a list of Transactions
     * @param accountIds (optional) The account ids used in the transaction rows
     * @param description (optional) 
     * @param description (optional) The description used in the transaction
     * @param pageNumber (optional) The number of the page to retrieve from the data source
     * @param pageSize (optional) The number of items in the page that must be retrieved from the data source
     */
    getList(accountIds: string[] | null | undefined, description: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined, cancelToken?: CancelToken | undefined): Promise<PaginatedListOfTransactionsGetListResponse> {
        let url_ = this.baseUrl + "/Transactions?";
        if (accountIds !== undefined && accountIds !== null)
            accountIds && accountIds.forEach(item => { url_ += "AccountIds=" + encodeURIComponent("" + item) + "&"; });
        if (description !== undefined && description !== null)
            url_ += "Description=" + encodeURIComponent("" + description) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processGetList(_response));
        });
    }

    protected processGetList(response: AxiosResponse): Promise<PaginatedListOfTransactionsGetListResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedListOfTransactionsGetListResponse.fromJS(resultData200);
            return Promise.resolve<PaginatedListOfTransactionsGetListResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedListOfTransactionsGetListResponse>(null as any);
    }

    /**
     * Creates a new Transaction
     * @param request The Transaction entity to create
     * @return The id of the newly created Transaction
     */
    create(request: TransactionsCreateRequest, cancelToken?: CancelToken | undefined): Promise<TransactionsCreateResponse> {
        let url_ = this.baseUrl + "/Transactions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCreate(_response));
        });
    }

    protected processCreate(response: AxiosResponse): Promise<TransactionsCreateResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TransactionsCreateResponse.fromJS(resultData200);
            return Promise.resolve<TransactionsCreateResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("The supplied Transaction object did not pass validation checks", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TransactionsCreateResponse>(null as any);
    }

    /**
     * Gets an existing Transaction
     * @param id The id of the Transaction
     * @return The Transaction with the specified id
     */
    get(id: string, cancelToken?: CancelToken | undefined): Promise<TransactionsGetResponse> {
        let url_ = this.baseUrl + "/Transactions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processGet(_response));
        });
    }

    protected processGet(response: AxiosResponse): Promise<TransactionsGetResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TransactionsGetResponse.fromJS(resultData200);
            return Promise.resolve<TransactionsGetResponse>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A Transaction with the specified id could not be found", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TransactionsGetResponse>(null as any);
    }

    /**
     * Updates an existing Transaction
     * @param id The id of the Transaction
     * @param request The Transaction entity to update
     * @return The Transaction was correctly updated
     */
    update(id: string, request: TransactionsUpdateRequest, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Transactions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUpdate(_response));
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("The supplied Transaction object did not pass validation checks", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A Transaction with the specified id could not be found", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Deletes an existing Transaction
     * @param id The id of the Transaction
     * @return Nothing
     */
    delete(id: string, cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/Transactions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processDelete(_response));
        });
    }

    protected processDelete(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

/** The result of the Account entities get list */
export class AccountsGetListResponse implements IAccountsGetListResponse {
    /** The id of the account */
    id!: string;
    /** The name of the account */
    name!: string;
    /** The type of the account */
    type!: AccountType;
    /** The total amount that the account has registered */
    totalAmount!: number;

    constructor(data?: IAccountsGetListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.totalAmount = _data["totalAmount"] !== undefined ? _data["totalAmount"] : <any>null;
        }
    }

    static fromJS(data: any): AccountsGetListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AccountsGetListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["totalAmount"] = this.totalAmount !== undefined ? this.totalAmount : <any>null;
        return data;
    }
}

/** The result of the Account entities get list */
export interface IAccountsGetListResponse {
    /** The id of the account */
    id: string;
    /** The name of the account */
    name: string;
    /** The type of the account */
    type: AccountType;
    /** The total amount that the account has registered */
    totalAmount: number;
}

export enum AccountType {
    Cash = 0,
    Expense = 1,
    Revenue = 2,
    Setup = 3,
    Debit = 4,
    Credit = 5,
}

/** The request to get a list of Account entities */
export class AccountsGetListRequest implements IAccountsGetListRequest {

    constructor(data?: IAccountsGetListRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): AccountsGetListRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AccountsGetListRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

/** The request to get a list of Account entities */
export interface IAccountsGetListRequest {
}

/** The result of the get request of a Account entity */
export class AccountsGetResponse implements IAccountsGetResponse {
    /** The id of the account */
    id!: string;
    /** The name of the account */
    name!: string;
    /** The type of the account */
    type!: AccountType;
    /** The total amount that the account has registered */
    totalAmount!: number;

    constructor(data?: IAccountsGetResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.totalAmount = _data["totalAmount"] !== undefined ? _data["totalAmount"] : <any>null;
        }
    }

    static fromJS(data: any): AccountsGetResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AccountsGetResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["totalAmount"] = this.totalAmount !== undefined ? this.totalAmount : <any>null;
        return data;
    }
}

/** The result of the get request of a Account entity */
export interface IAccountsGetResponse {
    /** The id of the account */
    id: string;
    /** The name of the account */
    name: string;
    /** The type of the account */
    type: AccountType;
    /** The total amount that the account has registered */
    totalAmount: number;
}

export class ProblemDetails implements IProblemDetails {
    type!: string | null;
    title!: string | null;
    status!: number | null;
    detail!: string | null;
    instance!: string | null;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.detail = _data["detail"] !== undefined ? _data["detail"] : <any>null;
            this.instance = _data["instance"] !== undefined ? _data["instance"] : <any>null;
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["detail"] = this.detail !== undefined ? this.detail : <any>null;
        data["instance"] = this.instance !== undefined ? this.instance : <any>null;
        return data;
    }
}

export interface IProblemDetails {
    type: string | null;
    title: string | null;
    status: number | null;
    detail: string | null;
    instance: string | null;

    [key: string]: any;
}

/** The result of the creation of a new Account entity */
export class AccountsCreateResponse implements IAccountsCreateResponse {
    /** The id of the newly created Account */
    id!: string;

    constructor(data?: IAccountsCreateResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
        }
    }

    static fromJS(data: any): AccountsCreateResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AccountsCreateResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        return data;
    }
}

/** The result of the creation of a new Account entity */
export interface IAccountsCreateResponse {
    /** The id of the newly created Account */
    id: string;
}

/** The request to create a new Account entity */
export class AccountsCreateRequest implements IAccountsCreateRequest {
    /** The name of the account */
    name!: string;
    /** The type of the account */
    type!: AccountType;

    constructor(data?: IAccountsCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
        }
    }

    static fromJS(data: any): AccountsCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AccountsCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data;
    }
}

/** The request to create a new Account entity */
export interface IAccountsCreateRequest {
    /** The name of the account */
    name: string;
    /** The type of the account */
    type: AccountType;
}

/** The request to update an existing account */
export class AccountsUpdateRequest implements IAccountsUpdateRequest {
    /** The name of the account */
    name!: string;
    /** The type of the account */
    type!: AccountType;

    constructor(data?: IAccountsUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
        }
    }

    static fromJS(data: any): AccountsUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AccountsUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data;
    }
}

/** The request to update an existing account */
export interface IAccountsUpdateRequest {
    /** The name of the account */
    name: string;
    /** The type of the account */
    type: AccountType;
}

/** This model represents a paginated list of generic results, allowing pagination to occur for better performance when retrieving large amounts of records from an endpoint. */
export class PaginatedListOfTransactionsGetListResponse implements IPaginatedListOfTransactionsGetListResponse {
    /** The collection of items that this PaginatedList object represents
             */
    items!: TransactionsGetListResponse[];
    /** The number of the page representing the current subset of items
             */
    pageNumber!: number;
    /** The total number of pages that could be retrieved with the current page size
             */
    totalPages!: number;
    /** The total count of items before pagination occurred
             */
    totalCount!: number;
    /** Describes if there is a previous page that can be retrieved by subtracting 1 from the page number
             */
    hasPreviousPage!: boolean;
    /** Describes if there is a next page that can be retrieved by adding 1 to the page number
             */
    hasNextPage!: boolean;

    constructor(data?: IPaginatedListOfTransactionsGetListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TransactionsGetListResponse.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
            this.pageNumber = _data["pageNumber"] !== undefined ? _data["pageNumber"] : <any>null;
            this.totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            this.hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            this.hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): PaginatedListOfTransactionsGetListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfTransactionsGetListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber !== undefined ? this.pageNumber : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

/** This model represents a paginated list of generic results, allowing pagination to occur for better performance when retrieving large amounts of records from an endpoint. */
export interface IPaginatedListOfTransactionsGetListResponse {
    /** The collection of items that this PaginatedList object represents
             */
    items: TransactionsGetListResponse[];
    /** The number of the page representing the current subset of items
             */
    pageNumber: number;
    /** The total number of pages that could be retrieved with the current page size
             */
    totalPages: number;
    /** The total count of items before pagination occurred
             */
    totalCount: number;
    /** Describes if there is a previous page that can be retrieved by subtracting 1 from the page number
             */
    hasPreviousPage: boolean;
    /** Describes if there is a next page that can be retrieved by adding 1 to the page number
             */
    hasNextPage: boolean;
}

/** The result of the Transaction entities get list */
export class TransactionsGetListResponse implements ITransactionsGetListResponse {
    /** The id of the transaction */
    id!: string;
    /** The date of the transaction */
    date!: DateTime;
    /** The description of the transaction */
    description!: string;
    /** The rows of the transaction */
    transactionRows!: TransactionRowsGetListResponse[];

    constructor(data?: ITransactionsGetListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.date = _data["date"] ? DateTime.fromISO(_data["date"].toString()) : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            if (Array.isArray(_data["transactionRows"])) {
                this.transactionRows = [] as any;
                for (let item of _data["transactionRows"])
                    this.transactionRows!.push(TransactionRowsGetListResponse.fromJS(item));
            }
            else {
                this.transactionRows = <any>null;
            }
        }
    }

    static fromJS(data: any): TransactionsGetListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionsGetListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["date"] = this.date ? this.date.toFormat('yyyy-MM-dd') : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        if (Array.isArray(this.transactionRows)) {
            data["transactionRows"] = [];
            for (let item of this.transactionRows)
                data["transactionRows"].push(item.toJSON());
        }
        return data;
    }
}

/** The result of the Transaction entities get list */
export interface ITransactionsGetListResponse {
    /** The id of the transaction */
    id: string;
    /** The date of the transaction */
    date: DateTime;
    /** The description of the transaction */
    description: string;
    /** The rows of the transaction */
    transactionRows: TransactionRowsGetListResponse[];
}

/** The row of a transaction get list response */
export class TransactionRowsGetListResponse implements ITransactionRowsGetListResponse {
    /** The id of the transaction row */
    id!: string;
    /** The progressive number of the transaction row in the scope of the transaction */
    rowCounter!: number;
    /** The id of the account */
    accountId!: string;
    /** The name of the account */
    accountName!: string;
    /** The debit amount of the transaction row */
    debit!: number | null;
    /** The credit amount of the transaction row */
    credit!: number | null;
    /** The description of the transaction row */
    description!: string | null;

    constructor(data?: ITransactionRowsGetListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.rowCounter = _data["rowCounter"] !== undefined ? _data["rowCounter"] : <any>null;
            this.accountId = _data["accountId"] !== undefined ? _data["accountId"] : <any>null;
            this.accountName = _data["accountName"] !== undefined ? _data["accountName"] : <any>null;
            this.debit = _data["debit"] !== undefined ? _data["debit"] : <any>null;
            this.credit = _data["credit"] !== undefined ? _data["credit"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
        }
    }

    static fromJS(data: any): TransactionRowsGetListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionRowsGetListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["rowCounter"] = this.rowCounter !== undefined ? this.rowCounter : <any>null;
        data["accountId"] = this.accountId !== undefined ? this.accountId : <any>null;
        data["accountName"] = this.accountName !== undefined ? this.accountName : <any>null;
        data["debit"] = this.debit !== undefined ? this.debit : <any>null;
        data["credit"] = this.credit !== undefined ? this.credit : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data;
    }
}

/** The row of a transaction get list response */
export interface ITransactionRowsGetListResponse {
    /** The id of the transaction row */
    id: string;
    /** The progressive number of the transaction row in the scope of the transaction */
    rowCounter: number;
    /** The id of the account */
    accountId: string;
    /** The name of the account */
    accountName: string;
    /** The debit amount of the transaction row */
    debit: number | null;
    /** The credit amount of the transaction row */
    credit: number | null;
    /** The description of the transaction row */
    description: string | null;
}

/** The result of the get request of a Transaction entity */
export class TransactionsGetResponse implements ITransactionsGetResponse {
    /** The id of the transaction */
    id!: string;
    /** The date of the transaction */
    date!: DateTime;
    /** The description of the transaction */
    description!: string;
    /** The rows of the transaction */
    transactionRows!: TransactionRowsGetResponse[];

    constructor(data?: ITransactionsGetResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.date = _data["date"] ? DateTime.fromISO(_data["date"].toString()) : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            if (Array.isArray(_data["transactionRows"])) {
                this.transactionRows = [] as any;
                for (let item of _data["transactionRows"])
                    this.transactionRows!.push(TransactionRowsGetResponse.fromJS(item));
            }
            else {
                this.transactionRows = <any>null;
            }
        }
    }

    static fromJS(data: any): TransactionsGetResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionsGetResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["date"] = this.date ? this.date.toFormat('yyyy-MM-dd') : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        if (Array.isArray(this.transactionRows)) {
            data["transactionRows"] = [];
            for (let item of this.transactionRows)
                data["transactionRows"].push(item.toJSON());
        }
        return data;
    }
}

/** The result of the get request of a Transaction entity */
export interface ITransactionsGetResponse {
    /** The id of the transaction */
    id: string;
    /** The date of the transaction */
    date: DateTime;
    /** The description of the transaction */
    description: string;
    /** The rows of the transaction */
    transactionRows: TransactionRowsGetResponse[];
}

/** The row of a transaction get response */
export class TransactionRowsGetResponse implements ITransactionRowsGetResponse {
    /** The id of the transaction row */
    id!: string;
    /** The progressive number of the transaction row in the scope of the transaction */
    rowCounter!: number;
    /** The id of the account */
    accountId!: string;
    /** The debit amount of the transaction row */
    debit!: number | null;
    /** The credit amount of the transaction row */
    credit!: number | null;
    /** The description of the transaction row */
    description!: string | null;

    constructor(data?: ITransactionRowsGetResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.rowCounter = _data["rowCounter"] !== undefined ? _data["rowCounter"] : <any>null;
            this.accountId = _data["accountId"] !== undefined ? _data["accountId"] : <any>null;
            this.debit = _data["debit"] !== undefined ? _data["debit"] : <any>null;
            this.credit = _data["credit"] !== undefined ? _data["credit"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
        }
    }

    static fromJS(data: any): TransactionRowsGetResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionRowsGetResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["rowCounter"] = this.rowCounter !== undefined ? this.rowCounter : <any>null;
        data["accountId"] = this.accountId !== undefined ? this.accountId : <any>null;
        data["debit"] = this.debit !== undefined ? this.debit : <any>null;
        data["credit"] = this.credit !== undefined ? this.credit : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data;
    }
}

/** The row of a transaction get response */
export interface ITransactionRowsGetResponse {
    /** The id of the transaction row */
    id: string;
    /** The progressive number of the transaction row in the scope of the transaction */
    rowCounter: number;
    /** The id of the account */
    accountId: string;
    /** The debit amount of the transaction row */
    debit: number | null;
    /** The credit amount of the transaction row */
    credit: number | null;
    /** The description of the transaction row */
    description: string | null;
}

/** The result of the creation of a new Transaction entity */
export class TransactionsCreateResponse implements ITransactionsCreateResponse {
    /** The id of the newly created Transaction */
    id!: string;

    constructor(data?: ITransactionsCreateResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
        }
    }

    static fromJS(data: any): TransactionsCreateResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionsCreateResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        return data;
    }
}

/** The result of the creation of a new Transaction entity */
export interface ITransactionsCreateResponse {
    /** The id of the newly created Transaction */
    id: string;
}

/** The request to create a new Transaction entity */
export class TransactionsCreateRequest implements ITransactionsCreateRequest {
    /** The date of the transaction */
    date!: DateTime;
    /** The description of the transaction */
    description!: string;
    /** The rows of the transaction */
    transactionRows!: TransactionRowsCreateRequest[];

    constructor(data?: ITransactionsCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? DateTime.fromISO(_data["date"].toString()) : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            if (Array.isArray(_data["transactionRows"])) {
                this.transactionRows = [] as any;
                for (let item of _data["transactionRows"])
                    this.transactionRows!.push(TransactionRowsCreateRequest.fromJS(item));
            }
            else {
                this.transactionRows = <any>null;
            }
        }
    }

    static fromJS(data: any): TransactionsCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionsCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toFormat('yyyy-MM-dd') : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        if (Array.isArray(this.transactionRows)) {
            data["transactionRows"] = [];
            for (let item of this.transactionRows)
                data["transactionRows"].push(item.toJSON());
        }
        return data;
    }
}

/** The request to create a new Transaction entity */
export interface ITransactionsCreateRequest {
    /** The date of the transaction */
    date: DateTime;
    /** The description of the transaction */
    description: string;
    /** The rows of the transaction */
    transactionRows: TransactionRowsCreateRequest[];
}

/** The row of a transaction create request */
export class TransactionRowsCreateRequest implements ITransactionRowsCreateRequest {
    /** The progressive number of the transaction row in the scope of the transaction */
    rowCounter!: number;
    /** The id of the account */
    accountId!: string;
    /** The debit amount of the transaction row */
    debit!: number | null;
    /** The credit amount of the transaction row */
    credit!: number | null;
    /** The description of the transaction row */
    description!: string | null;

    constructor(data?: ITransactionRowsCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rowCounter = _data["rowCounter"] !== undefined ? _data["rowCounter"] : <any>null;
            this.accountId = _data["accountId"] !== undefined ? _data["accountId"] : <any>null;
            this.debit = _data["debit"] !== undefined ? _data["debit"] : <any>null;
            this.credit = _data["credit"] !== undefined ? _data["credit"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
        }
    }

    static fromJS(data: any): TransactionRowsCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionRowsCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rowCounter"] = this.rowCounter !== undefined ? this.rowCounter : <any>null;
        data["accountId"] = this.accountId !== undefined ? this.accountId : <any>null;
        data["debit"] = this.debit !== undefined ? this.debit : <any>null;
        data["credit"] = this.credit !== undefined ? this.credit : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data;
    }
}

/** The row of a transaction create request */
export interface ITransactionRowsCreateRequest {
    /** The progressive number of the transaction row in the scope of the transaction */
    rowCounter: number;
    /** The id of the account */
    accountId: string;
    /** The debit amount of the transaction row */
    debit: number | null;
    /** The credit amount of the transaction row */
    credit: number | null;
    /** The description of the transaction row */
    description: string | null;
}

/** The request to update an existing transaction */
export class TransactionsUpdateRequest implements ITransactionsUpdateRequest {
    /** The date of the transaction */
    date!: DateTime;
    /** The description of the transaction */
    description!: string;
    /** The rows of the transaction */
    transactionRows!: TransactionRowsUpdateRequest[];

    constructor(data?: ITransactionsUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? DateTime.fromISO(_data["date"].toString()) : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            if (Array.isArray(_data["transactionRows"])) {
                this.transactionRows = [] as any;
                for (let item of _data["transactionRows"])
                    this.transactionRows!.push(TransactionRowsUpdateRequest.fromJS(item));
            }
            else {
                this.transactionRows = <any>null;
            }
        }
    }

    static fromJS(data: any): TransactionsUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionsUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toFormat('yyyy-MM-dd') : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        if (Array.isArray(this.transactionRows)) {
            data["transactionRows"] = [];
            for (let item of this.transactionRows)
                data["transactionRows"].push(item.toJSON());
        }
        return data;
    }
}

/** The request to update an existing transaction */
export interface ITransactionsUpdateRequest {
    /** The date of the transaction */
    date: DateTime;
    /** The description of the transaction */
    description: string;
    /** The rows of the transaction */
    transactionRows: TransactionRowsUpdateRequest[];
}

/** The row of a transaction create request */
export class TransactionRowsUpdateRequest implements ITransactionRowsUpdateRequest {
    /** The id of the transaction row */
    id!: string | null;
    /** The progressive number of the transaction row in the scope of the transaction */
    rowCounter!: number;
    /** The id of the account */
    accountId!: string;
    /** The debit amount of the transaction row */
    debit!: number | null;
    /** The credit amount of the transaction row */
    credit!: number | null;
    /** The description of the transaction row */
    description!: string | null;

    constructor(data?: ITransactionRowsUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.rowCounter = _data["rowCounter"] !== undefined ? _data["rowCounter"] : <any>null;
            this.accountId = _data["accountId"] !== undefined ? _data["accountId"] : <any>null;
            this.debit = _data["debit"] !== undefined ? _data["debit"] : <any>null;
            this.credit = _data["credit"] !== undefined ? _data["credit"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
        }
    }

    static fromJS(data: any): TransactionRowsUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionRowsUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["rowCounter"] = this.rowCounter !== undefined ? this.rowCounter : <any>null;
        data["accountId"] = this.accountId !== undefined ? this.accountId : <any>null;
        data["debit"] = this.debit !== undefined ? this.debit : <any>null;
        data["credit"] = this.credit !== undefined ? this.credit : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data;
    }
}

/** The row of a transaction create request */
export interface ITransactionRowsUpdateRequest {
    /** The id of the transaction row */
    id: string | null;
    /** The progressive number of the transaction row in the scope of the transaction */
    rowCounter: number;
    /** The id of the account */
    accountId: string;
    /** The debit amount of the transaction row */
    debit: number | null;
    /** The credit amount of the transaction row */
    credit: number | null;
    /** The description of the transaction row */
    description: string | null;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}

/* eslint-disable */
// noinspection ES6UnusedImports

/**
 * This file is needed for the automatic generation of the models of the backend API.
 * The generation is done via the NSwag toolchain, and the backend project is already
 * configured to generate the file "BackendClient.ts" on every successful build of the project.
 * Everything written in this file will be injected in the generated code by NSwag.
 */