//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import ServiceBase from "./ServiceBase";import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

import { DateTime, Duration } from "luxon";

export class AccountsClient extends ServiceBase {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        super();

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? this.getBaseUrl("");

    }

    /**
     * Gets a list of Accounts
     * @param totalAmountsFrom (optional) 
     * @param totalAmountsTo (optional) 
     */
    getList(totalAmountsFrom: DateTime | null | undefined, totalAmountsTo: DateTime | null | undefined, cancelToken?: CancelToken): Promise<AccountsGetListResponse[]> {
        let url_ = this.baseUrl + "/Accounts?";
        if (totalAmountsFrom !== undefined && totalAmountsFrom !== null)
            url_ += "TotalAmountsFrom=" + encodeURIComponent(totalAmountsFrom ? "" + totalAmountsFrom.toString() : "") + "&";
        if (totalAmountsTo !== undefined && totalAmountsTo !== null)
            url_ += "TotalAmountsTo=" + encodeURIComponent(totalAmountsTo ? "" + totalAmountsTo.toString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processGetList(_response));
        });
    }

    protected processGetList(response: AxiosResponse): Promise<AccountsGetListResponse[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AccountsGetListResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<AccountsGetListResponse[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AccountsGetListResponse[]>(null as any);
    }

    /**
     * Creates a new Account
     * @param request The Account entity to create
     * @return The id of the newly created Account
     */
    create(request: AccountsCreateRequest, cancelToken?: CancelToken): Promise<AccountsCreateResponse> {
        let url_ = this.baseUrl + "/Accounts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCreate(_response));
        });
    }

    protected processCreate(response: AxiosResponse): Promise<AccountsCreateResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AccountsCreateResponse.fromJS(resultData200);
            return Promise.resolve<AccountsCreateResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("The supplied Account object did not pass validation checks", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AccountsCreateResponse>(null as any);
    }

    /**
     * Gets an existing Account
     * @param id The id of the Account
     * @return The Account with the specified id
     */
    get(id: string, cancelToken?: CancelToken): Promise<AccountsGetResponse> {
        let url_ = this.baseUrl + "/Accounts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processGet(_response));
        });
    }

    protected processGet(response: AxiosResponse): Promise<AccountsGetResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AccountsGetResponse.fromJS(resultData200);
            return Promise.resolve<AccountsGetResponse>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A Account with the specified id could not be found", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AccountsGetResponse>(null as any);
    }

    /**
     * Updates an existing Account
     * @param id The id of the Account
     * @param request The Account entity to update
     * @return The Account was correctly updated
     */
    update(id: string, request: AccountsUpdateRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Accounts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUpdate(_response));
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("The supplied Account object did not pass validation checks", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A Account with the specified id could not be found", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Deletes an existing Account
     * @param id The id of the Account
     * @return Nothing
     */
    delete(id: string, cancelToken?: CancelToken): Promise<FileResponse> {
        let url_ = this.baseUrl + "/Accounts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processDelete(_response));
        });
    }

    protected processDelete(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Toggles the favourite status on an account
     * @param id The id of the Account
     * @param request The Account entity to update
     * @return The Account was correctly updated
     */
    favourite(id: string, request: AccountsFavouriteRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Accounts/{id}/Favourite";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processFavourite(_response));
        });
    }

    protected processFavourite(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("The supplied Account object did not pass validation checks", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A Account with the specified id could not be found", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class BankStatementsClient extends ServiceBase {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        super();

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? this.getBaseUrl("");

    }

    /**
     * Parses a new BankStatement
     * @param request The BankStatement entity to parse
     * @return The id of the newly created BankStatement
     */
    parse(request: BankStatementsParseRequest, cancelToken?: CancelToken): Promise<BankStatementsParseResponse> {
        let url_ = this.baseUrl + "/BankStatements/Parse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processParse(_response));
        });
    }

    protected processParse(response: AxiosResponse): Promise<BankStatementsParseResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BankStatementsParseResponse.fromJS(resultData200);
            return Promise.resolve<BankStatementsParseResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("The supplied BankStatement object did not pass validation checks", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BankStatementsParseResponse>(null as any);
    }

    /**
     * Gets an existing BankStatement
     * @param id The id of the BankStatement
     * @return The BankStatement with the specified id
     */
    get(id: string, cancelToken?: CancelToken): Promise<BankStatementGetResponse> {
        let url_ = this.baseUrl + "/BankStatements/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processGet(_response));
        });
    }

    protected processGet(response: AxiosResponse): Promise<BankStatementGetResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BankStatementGetResponse.fromJS(resultData200);
            return Promise.resolve<BankStatementGetResponse>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A BankStatement with the specified id could not be found", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BankStatementGetResponse>(null as any);
    }

    /**
     * Deletes an existing BankStatement
     * @param id The id of the BankStatement
     * @return The BankStatement was correctly deleted
     */
    delete(id: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/BankStatements/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processDelete(_response));
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A BankStatement with the specified id could not be found", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Gets a list of BankStatements
     * @param request (optional) 
     */
    getList(request: BankStatementsGetListRequest | undefined, cancelToken?: CancelToken): Promise<BankStatementsGetListResponse[]> {
        let url_ = this.baseUrl + "/BankStatements?";
        if (request === null)
            throw new Error("The parameter 'request' cannot be null.");
        else if (request !== undefined)
            url_ += "request=" + encodeURIComponent("" + request) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processGetList(_response));
        });
    }

    protected processGetList(response: AxiosResponse): Promise<BankStatementsGetListResponse[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BankStatementsGetListResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<BankStatementsGetListResponse[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BankStatementsGetListResponse[]>(null as any);
    }

    /**
     * Gets a list of Parsers
     * @param request (optional) 
     */
    parsersGetList(request: BankStatementParsersGetListRequest | undefined, cancelToken?: CancelToken): Promise<BankStatementParsersGetListResponse[]> {
        let url_ = this.baseUrl + "/BankStatements/Parsers?";
        if (request === null)
            throw new Error("The parameter 'request' cannot be null.");
        else if (request !== undefined)
            url_ += "request=" + encodeURIComponent("" + request) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processParsersGetList(_response));
        });
    }

    protected processParsersGetList(response: AxiosResponse): Promise<BankStatementParsersGetListResponse[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BankStatementParsersGetListResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<BankStatementParsersGetListResponse[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BankStatementParsersGetListResponse[]>(null as any);
    }
}

export class BudgetItemsClient extends ServiceBase {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        super();

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? this.getBaseUrl("");

    }

    /**
     * Gets a list of Budget Items
     * @param year (optional) 
     * @param month (optional) 
     */
    getList(year: number | undefined, month: number | undefined, cancelToken?: CancelToken): Promise<BudgetItemsGetListResponse[]> {
        let url_ = this.baseUrl + "/BudgetItems?";
        if (year === null)
            throw new Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "Year=" + encodeURIComponent("" + year) + "&";
        if (month === null)
            throw new Error("The parameter 'month' cannot be null.");
        else if (month !== undefined)
            url_ += "Month=" + encodeURIComponent("" + month) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processGetList(_response));
        });
    }

    protected processGetList(response: AxiosResponse): Promise<BudgetItemsGetListResponse[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BudgetItemsGetListResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<BudgetItemsGetListResponse[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BudgetItemsGetListResponse[]>(null as any);
    }

    /**
     * Creates, updates or deletes a Budget Item
     * @param request The Budget Item entity to create, update or delete
     * @return The id of the newly created or updated Budget Item, or null if it was deleted
     */
    upsert(request: BudgetItemsUpsertRequest, cancelToken?: CancelToken): Promise<BudgetItemsUpsertResponse> {
        let url_ = this.baseUrl + "/BudgetItems";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUpsert(_response));
        });
    }

    protected processUpsert(response: AxiosResponse): Promise<BudgetItemsUpsertResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BudgetItemsUpsertResponse.fromJS(resultData200);
            return Promise.resolve<BudgetItemsUpsertResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("The supplied Budget Item object did not pass validation checks", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BudgetItemsUpsertResponse>(null as any);
    }
}

export class CounterpartiesClient extends ServiceBase {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        super();

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? this.getBaseUrl("");

    }

    /**
     * Gets a list of Counterparties
     * @param name (optional) The name of the counterparties
     * @param pageNumber (optional) The number of the page to retrieve from the data source
     * @param pageSize (optional) The number of items in the page that must be retrieved from the data source
     */
    getList(name: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined, cancelToken?: CancelToken): Promise<PaginatedListOfCounterpartiesGetListResponse> {
        let url_ = this.baseUrl + "/Counterparties?";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processGetList(_response));
        });
    }

    protected processGetList(response: AxiosResponse): Promise<PaginatedListOfCounterpartiesGetListResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedListOfCounterpartiesGetListResponse.fromJS(resultData200);
            return Promise.resolve<PaginatedListOfCounterpartiesGetListResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedListOfCounterpartiesGetListResponse>(null as any);
    }

    /**
     * Creates a new Counterparty
     * @param request The Counterparty entity to create
     * @return The id of the newly created Counterparty
     */
    create(request: CounterpartiesCreateRequest, cancelToken?: CancelToken): Promise<CounterpartiesCreateResponse> {
        let url_ = this.baseUrl + "/Counterparties";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCreate(_response));
        });
    }

    protected processCreate(response: AxiosResponse): Promise<CounterpartiesCreateResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CounterpartiesCreateResponse.fromJS(resultData200);
            return Promise.resolve<CounterpartiesCreateResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("The supplied Counterparty object did not pass validation checks", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CounterpartiesCreateResponse>(null as any);
    }

    /**
     * Gets an existing Counterparty
     * @param id The id of the Counterparty
     * @return The Counterparty with the specified id
     */
    get(id: string, cancelToken?: CancelToken): Promise<CounterpartiesGetResponse> {
        let url_ = this.baseUrl + "/Counterparties/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processGet(_response));
        });
    }

    protected processGet(response: AxiosResponse): Promise<CounterpartiesGetResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CounterpartiesGetResponse.fromJS(resultData200);
            return Promise.resolve<CounterpartiesGetResponse>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A Counterparty with the specified id could not be found", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CounterpartiesGetResponse>(null as any);
    }

    /**
     * Updates an existing Counterparty
     * @param id The id of the Counterparty
     * @param request The Counterparty entity to update
     * @return The Counterparty was correctly updated
     */
    update(id: string, request: CounterpartiesUpdateRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Counterparties/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUpdate(_response));
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("The supplied Counterparty object did not pass validation checks", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A Counterparty with the specified id could not be found", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Deletes an existing Counterparty
     * @param id The id of the Counterparty
     * @return Nothing
     */
    delete(id: string, cancelToken?: CancelToken): Promise<FileResponse> {
        let url_ = this.baseUrl + "/Counterparties/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processDelete(_response));
        });
    }

    protected processDelete(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class TransactionsClient extends ServiceBase {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        super();

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? this.getBaseUrl("");

    }

    /**
     * Gets a list of Transactions
     * @param accountIds (optional) The account ids used in the transaction rows
     * @param counterpartyIds (optional) The counterparty ids used in the transaction
     * @param dateFrom (optional) The start date to use in the search of the transaction
     * @param dateTo (optional) The end date to use in the search of the transaction
     * @param pageNumber (optional) The number of the page to retrieve from the data source
     * @param pageSize (optional) The number of items in the page that must be retrieved from the data source
     */
    getList(accountIds: string[] | null | undefined, counterpartyIds: string[] | null | undefined, dateFrom: DateTime | null | undefined, dateTo: DateTime | null | undefined, pageNumber: number | undefined, pageSize: number | undefined, cancelToken?: CancelToken): Promise<PaginatedListOfTransactionsGetListResponse> {
        let url_ = this.baseUrl + "/Transactions?";
        if (accountIds !== undefined && accountIds !== null)
            accountIds && accountIds.forEach(item => { url_ += "AccountIds=" + encodeURIComponent("" + item) + "&"; });
        if (counterpartyIds !== undefined && counterpartyIds !== null)
            counterpartyIds && counterpartyIds.forEach(item => { url_ += "CounterpartyIds=" + encodeURIComponent("" + item) + "&"; });
        if (dateFrom !== undefined && dateFrom !== null)
            url_ += "DateFrom=" + encodeURIComponent(dateFrom ? "" + dateFrom.toString() : "") + "&";
        if (dateTo !== undefined && dateTo !== null)
            url_ += "DateTo=" + encodeURIComponent(dateTo ? "" + dateTo.toString() : "") + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processGetList(_response));
        });
    }

    protected processGetList(response: AxiosResponse): Promise<PaginatedListOfTransactionsGetListResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedListOfTransactionsGetListResponse.fromJS(resultData200);
            return Promise.resolve<PaginatedListOfTransactionsGetListResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedListOfTransactionsGetListResponse>(null as any);
    }

    /**
     * Creates a new Transaction
     * @param request The Transaction entity to create
     * @return The id of the newly created Transaction
     */
    create(request: TransactionsCreateRequest, cancelToken?: CancelToken): Promise<TransactionsCreateResponse> {
        let url_ = this.baseUrl + "/Transactions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCreate(_response));
        });
    }

    protected processCreate(response: AxiosResponse): Promise<TransactionsCreateResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TransactionsCreateResponse.fromJS(resultData200);
            return Promise.resolve<TransactionsCreateResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("The supplied Transaction object did not pass validation checks", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TransactionsCreateResponse>(null as any);
    }

    /**
     * Gets an existing Transaction
     * @param id The id of the Transaction
     * @return The Transaction with the specified id
     */
    get(id: string, cancelToken?: CancelToken): Promise<TransactionsGetResponse> {
        let url_ = this.baseUrl + "/Transactions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processGet(_response));
        });
    }

    protected processGet(response: AxiosResponse): Promise<TransactionsGetResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TransactionsGetResponse.fromJS(resultData200);
            return Promise.resolve<TransactionsGetResponse>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A Transaction with the specified id could not be found", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TransactionsGetResponse>(null as any);
    }

    /**
     * Updates an existing Transaction
     * @param id The id of the Transaction
     * @param request The Transaction entity to update
     * @return The Transaction was correctly updated
     */
    update(id: string, request: TransactionsUpdateRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Transactions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUpdate(_response));
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("The supplied Transaction object did not pass validation checks", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A Transaction with the specified id could not be found", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Deletes an existing Transaction
     * @param id The id of the Transaction
     * @return Nothing
     */
    delete(id: string, cancelToken?: CancelToken): Promise<FileResponse> {
        let url_ = this.baseUrl + "/Transactions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processDelete(_response));
        });
    }

    protected processDelete(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

/** The result of the Account entities get list */
export class AccountsGetListResponse implements IAccountsGetListResponse {
    /** The id of the account */
    id!: string;
    /** The name of the account */
    name!: string;
    /** The type of the account */
    type!: AccountType;
    /** Whether the account is marked as favourite */
    isFavourite!: boolean;
    /** The total amount that the account has registered */
    totalAmount!: number;

    constructor(data?: IAccountsGetListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.isFavourite = _data["isFavourite"] !== undefined ? _data["isFavourite"] : <any>null;
            this.totalAmount = _data["totalAmount"] !== undefined ? _data["totalAmount"] : <any>null;
        }
    }

    static fromJS(data: any): AccountsGetListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AccountsGetListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["isFavourite"] = this.isFavourite !== undefined ? this.isFavourite : <any>null;
        data["totalAmount"] = this.totalAmount !== undefined ? this.totalAmount : <any>null;
        return data;
    }
}

/** The result of the Account entities get list */
export interface IAccountsGetListResponse {
    /** The id of the account */
    id: string;
    /** The name of the account */
    name: string;
    /** The type of the account */
    type: AccountType;
    /** Whether the account is marked as favourite */
    isFavourite: boolean;
    /** The total amount that the account has registered */
    totalAmount: number;
}

export enum AccountType {
    Cash = 0,
    Expense = 1,
    Revenue = 2,
    Setup = 3,
    Debit = 4,
    Credit = 5,
}

/** The result of the get request of a Account entity */
export class AccountsGetResponse implements IAccountsGetResponse {
    /** The id of the account */
    id!: string;
    /** The name of the account */
    name!: string;
    /** The type of the account */
    type!: AccountType;
    /** Whether the account is marked as favourite */
    isFavourite!: boolean;
    /** The total amount that the account has registered */
    totalAmount!: number;

    constructor(data?: IAccountsGetResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.isFavourite = _data["isFavourite"] !== undefined ? _data["isFavourite"] : <any>null;
            this.totalAmount = _data["totalAmount"] !== undefined ? _data["totalAmount"] : <any>null;
        }
    }

    static fromJS(data: any): AccountsGetResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AccountsGetResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["isFavourite"] = this.isFavourite !== undefined ? this.isFavourite : <any>null;
        data["totalAmount"] = this.totalAmount !== undefined ? this.totalAmount : <any>null;
        return data;
    }
}

/** The result of the get request of a Account entity */
export interface IAccountsGetResponse {
    /** The id of the account */
    id: string;
    /** The name of the account */
    name: string;
    /** The type of the account */
    type: AccountType;
    /** Whether the account is marked as favourite */
    isFavourite: boolean;
    /** The total amount that the account has registered */
    totalAmount: number;
}

export class ProblemDetails implements IProblemDetails {
    type!: string | null;
    title!: string | null;
    status!: number | null;
    detail!: string | null;
    instance!: string | null;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.detail = _data["detail"] !== undefined ? _data["detail"] : <any>null;
            this.instance = _data["instance"] !== undefined ? _data["instance"] : <any>null;
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["detail"] = this.detail !== undefined ? this.detail : <any>null;
        data["instance"] = this.instance !== undefined ? this.instance : <any>null;
        return data;
    }
}

export interface IProblemDetails {
    type: string | null;
    title: string | null;
    status: number | null;
    detail: string | null;
    instance: string | null;

    [key: string]: any;
}

/** The result of the creation of a new Account entity */
export class AccountsCreateResponse implements IAccountsCreateResponse {
    /** The id of the newly created Account */
    id!: string;

    constructor(data?: IAccountsCreateResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
        }
    }

    static fromJS(data: any): AccountsCreateResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AccountsCreateResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        return data;
    }
}

/** The result of the creation of a new Account entity */
export interface IAccountsCreateResponse {
    /** The id of the newly created Account */
    id: string;
}

/** The request to create a new Account entity */
export class AccountsCreateRequest implements IAccountsCreateRequest {
    /** The name of the account */
    name!: string;
    /** The type of the account */
    type!: AccountType;

    constructor(data?: IAccountsCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
        }
    }

    static fromJS(data: any): AccountsCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AccountsCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data;
    }
}

/** The request to create a new Account entity */
export interface IAccountsCreateRequest {
    /** The name of the account */
    name: string;
    /** The type of the account */
    type: AccountType;
}

/** The request to update an existing account */
export class AccountsUpdateRequest implements IAccountsUpdateRequest {
    /** The name of the account */
    name!: string;
    /** The type of the account */
    type!: AccountType;

    constructor(data?: IAccountsUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
        }
    }

    static fromJS(data: any): AccountsUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AccountsUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data;
    }
}

/** The request to update an existing account */
export interface IAccountsUpdateRequest {
    /** The name of the account */
    name: string;
    /** The type of the account */
    type: AccountType;
}

/** The request to update the favourite status on an account Whether the account is marked as favourite */
export class AccountsFavouriteRequest implements IAccountsFavouriteRequest {
    isFavourite!: boolean;

    constructor(data?: IAccountsFavouriteRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isFavourite = _data["isFavourite"] !== undefined ? _data["isFavourite"] : <any>null;
        }
    }

    static fromJS(data: any): AccountsFavouriteRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AccountsFavouriteRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isFavourite"] = this.isFavourite !== undefined ? this.isFavourite : <any>null;
        return data;
    }
}

/** The request to update the favourite status on an account Whether the account is marked as favourite */
export interface IAccountsFavouriteRequest {
    isFavourite: boolean;
}

/** The result of the parsing of a new Bank Statement */
export class BankStatementsParseResponse implements IBankStatementsParseResponse {
    /** The id of the newly created bank statement */
    bankStatementId!: string;
    /** A list of warnings generated during the parsing process */
    warnings!: string[];

    constructor(data?: IBankStatementsParseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bankStatementId = _data["bankStatementId"] !== undefined ? _data["bankStatementId"] : <any>null;
            if (Array.isArray(_data["warnings"])) {
                this.warnings = [] as any;
                for (let item of _data["warnings"])
                    this.warnings!.push(item);
            }
            else {
                this.warnings = <any>null;
            }
        }
    }

    static fromJS(data: any): BankStatementsParseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BankStatementsParseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankStatementId"] = this.bankStatementId !== undefined ? this.bankStatementId : <any>null;
        if (Array.isArray(this.warnings)) {
            data["warnings"] = [];
            for (let item of this.warnings)
                data["warnings"].push(item);
        }
        return data;
    }
}

/** The result of the parsing of a new Bank Statement */
export interface IBankStatementsParseResponse {
    /** The id of the newly created bank statement */
    bankStatementId: string;
    /** A list of warnings generated during the parsing process */
    warnings: string[];
}

/** The request to parse a new Bank Statement */
export class BankStatementsParseRequest implements IBankStatementsParseRequest {
    /** The content of the bank statement */
    inputFileContents!: string;
    /** The filename of the bank statement */
    inputFileName!: string;
    /** The id of the parser to use */
    parserId!: string;
    /** The id of the account to which this bank statement refers to */
    importToAccountId!: string;

    constructor(data?: IBankStatementsParseRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.inputFileContents = _data["inputFileContents"] !== undefined ? _data["inputFileContents"] : <any>null;
            this.inputFileName = _data["inputFileName"] !== undefined ? _data["inputFileName"] : <any>null;
            this.parserId = _data["parserId"] !== undefined ? _data["parserId"] : <any>null;
            this.importToAccountId = _data["importToAccountId"] !== undefined ? _data["importToAccountId"] : <any>null;
        }
    }

    static fromJS(data: any): BankStatementsParseRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BankStatementsParseRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inputFileContents"] = this.inputFileContents !== undefined ? this.inputFileContents : <any>null;
        data["inputFileName"] = this.inputFileName !== undefined ? this.inputFileName : <any>null;
        data["parserId"] = this.parserId !== undefined ? this.parserId : <any>null;
        data["importToAccountId"] = this.importToAccountId !== undefined ? this.importToAccountId : <any>null;
        return data;
    }
}

/** The request to parse a new Bank Statement */
export interface IBankStatementsParseRequest {
    /** The content of the bank statement */
    inputFileContents: string;
    /** The filename of the bank statement */
    inputFileName: string;
    /** The id of the parser to use */
    parserId: string;
    /** The id of the account to which this bank statement refers to */
    importToAccountId: string;
}

/** The result of the BankStatement entity get */
export class BankStatementGetResponse implements IBankStatementGetResponse {
    /** The id of the bank statement */
    id!: string;
    /** The file name of the bank statement */
    fileName!: string;
    /** The parser name used for parsing the bank statement */
    parserName!: string;
    /** The list of transactions parsed from the bank statement */
    transactions!: TransactionsGetListResponse[];

    constructor(data?: IBankStatementGetResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.fileName = _data["fileName"] !== undefined ? _data["fileName"] : <any>null;
            this.parserName = _data["parserName"] !== undefined ? _data["parserName"] : <any>null;
            if (Array.isArray(_data["transactions"])) {
                this.transactions = [] as any;
                for (let item of _data["transactions"])
                    this.transactions!.push(TransactionsGetListResponse.fromJS(item));
            }
            else {
                this.transactions = <any>null;
            }
        }
    }

    static fromJS(data: any): BankStatementGetResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BankStatementGetResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["fileName"] = this.fileName !== undefined ? this.fileName : <any>null;
        data["parserName"] = this.parserName !== undefined ? this.parserName : <any>null;
        if (Array.isArray(this.transactions)) {
            data["transactions"] = [];
            for (let item of this.transactions)
                data["transactions"].push(item.toJSON());
        }
        return data;
    }
}

/** The result of the BankStatement entity get */
export interface IBankStatementGetResponse {
    /** The id of the bank statement */
    id: string;
    /** The file name of the bank statement */
    fileName: string;
    /** The parser name used for parsing the bank statement */
    parserName: string;
    /** The list of transactions parsed from the bank statement */
    transactions: TransactionsGetListResponse[];
}

/** The result of the Transaction entities get list */
export class TransactionsGetListResponse implements ITransactionsGetListResponse {
    /** The id of the transaction */
    id!: string;
    /** The date of the transaction */
    date!: DateTime;
    /** The id of the counterparty of the transaction */
    counterpartyId!: string | null;
    /** The name of the counterparty of the transaction */
    counterpartyName!: string;
    /** The rows of the transaction */
    transactionRows!: TransactionRowsGetListResponse[];
    /** The JSON representation of the raw import data of a bank statement */
    rawImportData!: string | null;
    /** The status of the transaction */
    status!: TransactionStatus;
    /** The id of the potential duplicate of the transaction */
    potentialDuplicateOfTransactionId!: string | null;

    constructor(data?: ITransactionsGetListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.date = _data["date"] ? DateTime.fromISO(_data["date"].toString()) : <any>null;
            this.counterpartyId = _data["counterpartyId"] !== undefined ? _data["counterpartyId"] : <any>null;
            this.counterpartyName = _data["counterpartyName"] !== undefined ? _data["counterpartyName"] : <any>null;
            if (Array.isArray(_data["transactionRows"])) {
                this.transactionRows = [] as any;
                for (let item of _data["transactionRows"])
                    this.transactionRows!.push(TransactionRowsGetListResponse.fromJS(item));
            }
            else {
                this.transactionRows = <any>null;
            }
            this.rawImportData = _data["rawImportData"] !== undefined ? _data["rawImportData"] : <any>null;
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.potentialDuplicateOfTransactionId = _data["potentialDuplicateOfTransactionId"] !== undefined ? _data["potentialDuplicateOfTransactionId"] : <any>null;
        }
    }

    static fromJS(data: any): TransactionsGetListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionsGetListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["date"] = this.date ? this.date.toFormat('yyyy-MM-dd') : <any>null;
        data["counterpartyId"] = this.counterpartyId !== undefined ? this.counterpartyId : <any>null;
        data["counterpartyName"] = this.counterpartyName !== undefined ? this.counterpartyName : <any>null;
        if (Array.isArray(this.transactionRows)) {
            data["transactionRows"] = [];
            for (let item of this.transactionRows)
                data["transactionRows"].push(item.toJSON());
        }
        data["rawImportData"] = this.rawImportData !== undefined ? this.rawImportData : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["potentialDuplicateOfTransactionId"] = this.potentialDuplicateOfTransactionId !== undefined ? this.potentialDuplicateOfTransactionId : <any>null;
        return data;
    }
}

/** The result of the Transaction entities get list */
export interface ITransactionsGetListResponse {
    /** The id of the transaction */
    id: string;
    /** The date of the transaction */
    date: DateTime;
    /** The id of the counterparty of the transaction */
    counterpartyId: string | null;
    /** The name of the counterparty of the transaction */
    counterpartyName: string;
    /** The rows of the transaction */
    transactionRows: TransactionRowsGetListResponse[];
    /** The JSON representation of the raw import data of a bank statement */
    rawImportData: string | null;
    /** The status of the transaction */
    status: TransactionStatus;
    /** The id of the potential duplicate of the transaction */
    potentialDuplicateOfTransactionId: string | null;
}

/** The row of a transaction get list response */
export class TransactionRowsGetListResponse implements ITransactionRowsGetListResponse {
    /** The id of the transaction row */
    id!: string;
    /** The progressive number of the transaction row in the scope of the transaction */
    rowCounter!: number;
    /** The id of the account */
    accountId!: string | null;
    /** The name of the account */
    accountName!: string | null;
    /** The debit amount of the transaction row */
    debit!: number | null;
    /** The credit amount of the transaction row */
    credit!: number | null;
    /** The description of the transaction row */
    description!: string | null;

    constructor(data?: ITransactionRowsGetListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.rowCounter = _data["rowCounter"] !== undefined ? _data["rowCounter"] : <any>null;
            this.accountId = _data["accountId"] !== undefined ? _data["accountId"] : <any>null;
            this.accountName = _data["accountName"] !== undefined ? _data["accountName"] : <any>null;
            this.debit = _data["debit"] !== undefined ? _data["debit"] : <any>null;
            this.credit = _data["credit"] !== undefined ? _data["credit"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
        }
    }

    static fromJS(data: any): TransactionRowsGetListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionRowsGetListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["rowCounter"] = this.rowCounter !== undefined ? this.rowCounter : <any>null;
        data["accountId"] = this.accountId !== undefined ? this.accountId : <any>null;
        data["accountName"] = this.accountName !== undefined ? this.accountName : <any>null;
        data["debit"] = this.debit !== undefined ? this.debit : <any>null;
        data["credit"] = this.credit !== undefined ? this.credit : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data;
    }
}

/** The row of a transaction get list response */
export interface ITransactionRowsGetListResponse {
    /** The id of the transaction row */
    id: string;
    /** The progressive number of the transaction row in the scope of the transaction */
    rowCounter: number;
    /** The id of the account */
    accountId: string | null;
    /** The name of the account */
    accountName: string | null;
    /** The debit amount of the transaction row */
    debit: number | null;
    /** The credit amount of the transaction row */
    credit: number | null;
    /** The description of the transaction row */
    description: string | null;
}

export enum TransactionStatus {
    Confirmed = 0,
    PendingImportReview = 1,
    PotentialDuplicate = 2,
}

/** The result of the BankStatement entities get list */
export class BankStatementsGetListResponse implements IBankStatementsGetListResponse {
    /** The id of the bank statement */
    id!: string;
    /** The file name of the bank statement */
    fileName!: string;
    /** The parser id used for parsing the bank statement */
    parserId!: string;
    /** The parser name used for parsing the bank statement */
    parserName!: string;
    /** The number of transactions parsed from the bank statement */
    transactionsCount!: number;

    constructor(data?: IBankStatementsGetListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.fileName = _data["fileName"] !== undefined ? _data["fileName"] : <any>null;
            this.parserId = _data["parserId"] !== undefined ? _data["parserId"] : <any>null;
            this.parserName = _data["parserName"] !== undefined ? _data["parserName"] : <any>null;
            this.transactionsCount = _data["transactionsCount"] !== undefined ? _data["transactionsCount"] : <any>null;
        }
    }

    static fromJS(data: any): BankStatementsGetListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BankStatementsGetListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["fileName"] = this.fileName !== undefined ? this.fileName : <any>null;
        data["parserId"] = this.parserId !== undefined ? this.parserId : <any>null;
        data["parserName"] = this.parserName !== undefined ? this.parserName : <any>null;
        data["transactionsCount"] = this.transactionsCount !== undefined ? this.transactionsCount : <any>null;
        return data;
    }
}

/** The result of the BankStatement entities get list */
export interface IBankStatementsGetListResponse {
    /** The id of the bank statement */
    id: string;
    /** The file name of the bank statement */
    fileName: string;
    /** The parser id used for parsing the bank statement */
    parserId: string;
    /** The parser name used for parsing the bank statement */
    parserName: string;
    /** The number of transactions parsed from the bank statement */
    transactionsCount: number;
}

/** The request to get a list of BankStatement entities */
export class BankStatementsGetListRequest implements IBankStatementsGetListRequest {

    constructor(data?: IBankStatementsGetListRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): BankStatementsGetListRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BankStatementsGetListRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

/** The request to get a list of BankStatement entities */
export interface IBankStatementsGetListRequest {
}

/** The result of the BankStatement parsers get list */
export class BankStatementParsersGetListResponse implements IBankStatementParsersGetListResponse {
    /** The globally unique id of the parser */
    parserId!: string;
    /** The parser display name */
    parserDisplayName!: string;

    constructor(data?: IBankStatementParsersGetListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parserId = _data["parserId"] !== undefined ? _data["parserId"] : <any>null;
            this.parserDisplayName = _data["parserDisplayName"] !== undefined ? _data["parserDisplayName"] : <any>null;
        }
    }

    static fromJS(data: any): BankStatementParsersGetListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BankStatementParsersGetListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parserId"] = this.parserId !== undefined ? this.parserId : <any>null;
        data["parserDisplayName"] = this.parserDisplayName !== undefined ? this.parserDisplayName : <any>null;
        return data;
    }
}

/** The result of the BankStatement parsers get list */
export interface IBankStatementParsersGetListResponse {
    /** The globally unique id of the parser */
    parserId: string;
    /** The parser display name */
    parserDisplayName: string;
}

/** The request to get a list of BankStatement parsers */
export class BankStatementParsersGetListRequest implements IBankStatementParsersGetListRequest {

    constructor(data?: IBankStatementParsersGetListRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): BankStatementParsersGetListRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BankStatementParsersGetListRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

/** The request to get a list of BankStatement parsers */
export interface IBankStatementParsersGetListRequest {
}

/** The result of the Budget Item entities get list */
export class BudgetItemsGetListResponse implements IBudgetItemsGetListResponse {
    id!: string;
    accountId!: string;
    accountType!: AccountType;
    year!: number;
    month!: number;
    amount!: number;

    constructor(data?: IBudgetItemsGetListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.accountId = _data["accountId"] !== undefined ? _data["accountId"] : <any>null;
            this.accountType = _data["accountType"] !== undefined ? _data["accountType"] : <any>null;
            this.year = _data["year"] !== undefined ? _data["year"] : <any>null;
            this.month = _data["month"] !== undefined ? _data["month"] : <any>null;
            this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
        }
    }

    static fromJS(data: any): BudgetItemsGetListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetItemsGetListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["accountId"] = this.accountId !== undefined ? this.accountId : <any>null;
        data["accountType"] = this.accountType !== undefined ? this.accountType : <any>null;
        data["year"] = this.year !== undefined ? this.year : <any>null;
        data["month"] = this.month !== undefined ? this.month : <any>null;
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        return data;
    }
}

/** The result of the Budget Item entities get list */
export interface IBudgetItemsGetListResponse {
    id: string;
    accountId: string;
    accountType: AccountType;
    year: number;
    month: number;
    amount: number;
}

/** The result of the creation or update of a new Budget Item entity */
export class BudgetItemsUpsertResponse implements IBudgetItemsUpsertResponse {
    /** The id of the newly created or updated Budget Item */
    id!: string | null;

    constructor(data?: IBudgetItemsUpsertResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
        }
    }

    static fromJS(data: any): BudgetItemsUpsertResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetItemsUpsertResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        return data;
    }
}

/** The result of the creation or update of a new Budget Item entity */
export interface IBudgetItemsUpsertResponse {
    /** The id of the newly created or updated Budget Item */
    id: string | null;
}

/** The request to insert or update a budget item */
export class BudgetItemsUpsertRequest implements IBudgetItemsUpsertRequest {
    accountId!: string;
    year!: number;
    month!: number;
    amount!: number | null;

    constructor(data?: IBudgetItemsUpsertRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountId = _data["accountId"] !== undefined ? _data["accountId"] : <any>null;
            this.year = _data["year"] !== undefined ? _data["year"] : <any>null;
            this.month = _data["month"] !== undefined ? _data["month"] : <any>null;
            this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
        }
    }

    static fromJS(data: any): BudgetItemsUpsertRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetItemsUpsertRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountId"] = this.accountId !== undefined ? this.accountId : <any>null;
        data["year"] = this.year !== undefined ? this.year : <any>null;
        data["month"] = this.month !== undefined ? this.month : <any>null;
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        return data;
    }
}

/** The request to insert or update a budget item */
export interface IBudgetItemsUpsertRequest {
    accountId: string;
    year: number;
    month: number;
    amount: number | null;
}

/** This model represents a paginated list of generic results, allowing pagination to occur for better performance when retrieving large amounts of records from an endpoint. */
export class PaginatedListOfCounterpartiesGetListResponse implements IPaginatedListOfCounterpartiesGetListResponse {
    /** The collection of items that this PaginatedList object represents
             */
    items!: CounterpartiesGetListResponse[];
    /** The number of the page representing the current subset of items
             */
    pageNumber!: number;
    /** The total number of pages that could be retrieved with the current page size
             */
    totalPages!: number;
    /** The total count of items before pagination occurred
             */
    totalCount!: number;
    /** Describes if there is a previous page that can be retrieved by subtracting 1 from the page number
             */
    hasPreviousPage!: boolean;
    /** Describes if there is a next page that can be retrieved by adding 1 to the page number
             */
    hasNextPage!: boolean;

    constructor(data?: IPaginatedListOfCounterpartiesGetListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CounterpartiesGetListResponse.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
            this.pageNumber = _data["pageNumber"] !== undefined ? _data["pageNumber"] : <any>null;
            this.totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            this.hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            this.hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): PaginatedListOfCounterpartiesGetListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfCounterpartiesGetListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber !== undefined ? this.pageNumber : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

/** This model represents a paginated list of generic results, allowing pagination to occur for better performance when retrieving large amounts of records from an endpoint. */
export interface IPaginatedListOfCounterpartiesGetListResponse {
    /** The collection of items that this PaginatedList object represents
             */
    items: CounterpartiesGetListResponse[];
    /** The number of the page representing the current subset of items
             */
    pageNumber: number;
    /** The total number of pages that could be retrieved with the current page size
             */
    totalPages: number;
    /** The total count of items before pagination occurred
             */
    totalCount: number;
    /** Describes if there is a previous page that can be retrieved by subtracting 1 from the page number
             */
    hasPreviousPage: boolean;
    /** Describes if there is a next page that can be retrieved by adding 1 to the page number
             */
    hasNextPage: boolean;
}

/** The result of the Counterparty entities get list */
export class CounterpartiesGetListResponse implements ICounterpartiesGetListResponse {
    /** The id of the counterparty */
    id!: string;
    /** The name of the counterparty */
    name!: string;

    constructor(data?: ICounterpartiesGetListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): CounterpartiesGetListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CounterpartiesGetListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data;
    }
}

/** The result of the Counterparty entities get list */
export interface ICounterpartiesGetListResponse {
    /** The id of the counterparty */
    id: string;
    /** The name of the counterparty */
    name: string;
}

/** The result of the get request of a Counterparty entity */
export class CounterpartiesGetResponse implements ICounterpartiesGetResponse {
    /** The id of the counterparty */
    id!: string;
    /** The name of the counterparty */
    name!: string;

    constructor(data?: ICounterpartiesGetResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): CounterpartiesGetResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CounterpartiesGetResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data;
    }
}

/** The result of the get request of a Counterparty entity */
export interface ICounterpartiesGetResponse {
    /** The id of the counterparty */
    id: string;
    /** The name of the counterparty */
    name: string;
}

/** The result of the creation of a new Counterparty entity */
export class CounterpartiesCreateResponse implements ICounterpartiesCreateResponse {
    /** The id of the newly created Counterparty */
    id!: string;

    constructor(data?: ICounterpartiesCreateResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
        }
    }

    static fromJS(data: any): CounterpartiesCreateResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CounterpartiesCreateResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        return data;
    }
}

/** The result of the creation of a new Counterparty entity */
export interface ICounterpartiesCreateResponse {
    /** The id of the newly created Counterparty */
    id: string;
}

/** The request to create a new Counterparty entity */
export class CounterpartiesCreateRequest implements ICounterpartiesCreateRequest {
    /** The name of the counterparty */
    name!: string;

    constructor(data?: ICounterpartiesCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): CounterpartiesCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CounterpartiesCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data;
    }
}

/** The request to create a new Counterparty entity */
export interface ICounterpartiesCreateRequest {
    /** The name of the counterparty */
    name: string;
}

/** The request to update an existing counterparty */
export class CounterpartiesUpdateRequest implements ICounterpartiesUpdateRequest {
    /** The name of the counterparty */
    name!: string;

    constructor(data?: ICounterpartiesUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): CounterpartiesUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CounterpartiesUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data;
    }
}

/** The request to update an existing counterparty */
export interface ICounterpartiesUpdateRequest {
    /** The name of the counterparty */
    name: string;
}

/** This model represents a paginated list of generic results, allowing pagination to occur for better performance when retrieving large amounts of records from an endpoint. */
export class PaginatedListOfTransactionsGetListResponse implements IPaginatedListOfTransactionsGetListResponse {
    /** The collection of items that this PaginatedList object represents
             */
    items!: TransactionsGetListResponse[];
    /** The number of the page representing the current subset of items
             */
    pageNumber!: number;
    /** The total number of pages that could be retrieved with the current page size
             */
    totalPages!: number;
    /** The total count of items before pagination occurred
             */
    totalCount!: number;
    /** Describes if there is a previous page that can be retrieved by subtracting 1 from the page number
             */
    hasPreviousPage!: boolean;
    /** Describes if there is a next page that can be retrieved by adding 1 to the page number
             */
    hasNextPage!: boolean;

    constructor(data?: IPaginatedListOfTransactionsGetListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TransactionsGetListResponse.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
            this.pageNumber = _data["pageNumber"] !== undefined ? _data["pageNumber"] : <any>null;
            this.totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            this.hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            this.hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): PaginatedListOfTransactionsGetListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfTransactionsGetListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber !== undefined ? this.pageNumber : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

/** This model represents a paginated list of generic results, allowing pagination to occur for better performance when retrieving large amounts of records from an endpoint. */
export interface IPaginatedListOfTransactionsGetListResponse {
    /** The collection of items that this PaginatedList object represents
             */
    items: TransactionsGetListResponse[];
    /** The number of the page representing the current subset of items
             */
    pageNumber: number;
    /** The total number of pages that could be retrieved with the current page size
             */
    totalPages: number;
    /** The total count of items before pagination occurred
             */
    totalCount: number;
    /** Describes if there is a previous page that can be retrieved by subtracting 1 from the page number
             */
    hasPreviousPage: boolean;
    /** Describes if there is a next page that can be retrieved by adding 1 to the page number
             */
    hasNextPage: boolean;
}

/** The result of the get request of a Transaction entity */
export class TransactionsGetResponse implements ITransactionsGetResponse {
    /** The id of the transaction */
    id!: string;
    /** The date of the transaction */
    date!: DateTime;
    /** The id of the counterparty of the transaction */
    counterpartyId!: string | null;
    /** The rows of the transaction */
    transactionRows!: TransactionRowsGetResponse[];

    constructor(data?: ITransactionsGetResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.date = _data["date"] ? DateTime.fromISO(_data["date"].toString()) : <any>null;
            this.counterpartyId = _data["counterpartyId"] !== undefined ? _data["counterpartyId"] : <any>null;
            if (Array.isArray(_data["transactionRows"])) {
                this.transactionRows = [] as any;
                for (let item of _data["transactionRows"])
                    this.transactionRows!.push(TransactionRowsGetResponse.fromJS(item));
            }
            else {
                this.transactionRows = <any>null;
            }
        }
    }

    static fromJS(data: any): TransactionsGetResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionsGetResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["date"] = this.date ? this.date.toFormat('yyyy-MM-dd') : <any>null;
        data["counterpartyId"] = this.counterpartyId !== undefined ? this.counterpartyId : <any>null;
        if (Array.isArray(this.transactionRows)) {
            data["transactionRows"] = [];
            for (let item of this.transactionRows)
                data["transactionRows"].push(item.toJSON());
        }
        return data;
    }
}

/** The result of the get request of a Transaction entity */
export interface ITransactionsGetResponse {
    /** The id of the transaction */
    id: string;
    /** The date of the transaction */
    date: DateTime;
    /** The id of the counterparty of the transaction */
    counterpartyId: string | null;
    /** The rows of the transaction */
    transactionRows: TransactionRowsGetResponse[];
}

/** The row of a transaction get response */
export class TransactionRowsGetResponse implements ITransactionRowsGetResponse {
    /** The id of the transaction row */
    id!: string;
    /** The progressive number of the transaction row in the scope of the transaction */
    rowCounter!: number;
    /** The id of the account */
    accountId!: string | null;
    /** The debit amount of the transaction row */
    debit!: number | null;
    /** The credit amount of the transaction row */
    credit!: number | null;
    /** The description of the transaction row */
    description!: string | null;

    constructor(data?: ITransactionRowsGetResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.rowCounter = _data["rowCounter"] !== undefined ? _data["rowCounter"] : <any>null;
            this.accountId = _data["accountId"] !== undefined ? _data["accountId"] : <any>null;
            this.debit = _data["debit"] !== undefined ? _data["debit"] : <any>null;
            this.credit = _data["credit"] !== undefined ? _data["credit"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
        }
    }

    static fromJS(data: any): TransactionRowsGetResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionRowsGetResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["rowCounter"] = this.rowCounter !== undefined ? this.rowCounter : <any>null;
        data["accountId"] = this.accountId !== undefined ? this.accountId : <any>null;
        data["debit"] = this.debit !== undefined ? this.debit : <any>null;
        data["credit"] = this.credit !== undefined ? this.credit : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data;
    }
}

/** The row of a transaction get response */
export interface ITransactionRowsGetResponse {
    /** The id of the transaction row */
    id: string;
    /** The progressive number of the transaction row in the scope of the transaction */
    rowCounter: number;
    /** The id of the account */
    accountId: string | null;
    /** The debit amount of the transaction row */
    debit: number | null;
    /** The credit amount of the transaction row */
    credit: number | null;
    /** The description of the transaction row */
    description: string | null;
}

/** The result of the creation of a new Transaction entity */
export class TransactionsCreateResponse implements ITransactionsCreateResponse {
    /** The id of the newly created Transaction */
    id!: string;

    constructor(data?: ITransactionsCreateResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
        }
    }

    static fromJS(data: any): TransactionsCreateResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionsCreateResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        return data;
    }
}

/** The result of the creation of a new Transaction entity */
export interface ITransactionsCreateResponse {
    /** The id of the newly created Transaction */
    id: string;
}

/** The request to create a new Transaction entity */
export class TransactionsCreateRequest implements ITransactionsCreateRequest {
    /** The date of the transaction */
    date!: DateTime;
    /** The id of the counterparty of the transaction */
    counterpartyId!: string;
    /** The rows of the transaction */
    transactionRows!: TransactionRowsCreateRequest[];

    constructor(data?: ITransactionsCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? DateTime.fromISO(_data["date"].toString()) : <any>null;
            this.counterpartyId = _data["counterpartyId"] !== undefined ? _data["counterpartyId"] : <any>null;
            if (Array.isArray(_data["transactionRows"])) {
                this.transactionRows = [] as any;
                for (let item of _data["transactionRows"])
                    this.transactionRows!.push(TransactionRowsCreateRequest.fromJS(item));
            }
            else {
                this.transactionRows = <any>null;
            }
        }
    }

    static fromJS(data: any): TransactionsCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionsCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toFormat('yyyy-MM-dd') : <any>null;
        data["counterpartyId"] = this.counterpartyId !== undefined ? this.counterpartyId : <any>null;
        if (Array.isArray(this.transactionRows)) {
            data["transactionRows"] = [];
            for (let item of this.transactionRows)
                data["transactionRows"].push(item.toJSON());
        }
        return data;
    }
}

/** The request to create a new Transaction entity */
export interface ITransactionsCreateRequest {
    /** The date of the transaction */
    date: DateTime;
    /** The id of the counterparty of the transaction */
    counterpartyId: string;
    /** The rows of the transaction */
    transactionRows: TransactionRowsCreateRequest[];
}

/** The row of a transaction create request */
export class TransactionRowsCreateRequest implements ITransactionRowsCreateRequest {
    /** The progressive number of the transaction row in the scope of the transaction */
    rowCounter!: number;
    /** The id of the account */
    accountId!: string;
    /** The debit amount of the transaction row */
    debit!: number | null;
    /** The credit amount of the transaction row */
    credit!: number | null;
    /** The description of the transaction row */
    description!: string | null;

    constructor(data?: ITransactionRowsCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rowCounter = _data["rowCounter"] !== undefined ? _data["rowCounter"] : <any>null;
            this.accountId = _data["accountId"] !== undefined ? _data["accountId"] : <any>null;
            this.debit = _data["debit"] !== undefined ? _data["debit"] : <any>null;
            this.credit = _data["credit"] !== undefined ? _data["credit"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
        }
    }

    static fromJS(data: any): TransactionRowsCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionRowsCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rowCounter"] = this.rowCounter !== undefined ? this.rowCounter : <any>null;
        data["accountId"] = this.accountId !== undefined ? this.accountId : <any>null;
        data["debit"] = this.debit !== undefined ? this.debit : <any>null;
        data["credit"] = this.credit !== undefined ? this.credit : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data;
    }
}

/** The row of a transaction create request */
export interface ITransactionRowsCreateRequest {
    /** The progressive number of the transaction row in the scope of the transaction */
    rowCounter: number;
    /** The id of the account */
    accountId: string;
    /** The debit amount of the transaction row */
    debit: number | null;
    /** The credit amount of the transaction row */
    credit: number | null;
    /** The description of the transaction row */
    description: string | null;
}

/** The request to update an existing transaction */
export class TransactionsUpdateRequest implements ITransactionsUpdateRequest {
    /** The date of the transaction */
    date!: DateTime;
    /** The id of the counterparty of the transaction */
    counterpartyId!: string;
    /** The rows of the transaction */
    transactionRows!: TransactionRowsUpdateRequest[];

    constructor(data?: ITransactionsUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? DateTime.fromISO(_data["date"].toString()) : <any>null;
            this.counterpartyId = _data["counterpartyId"] !== undefined ? _data["counterpartyId"] : <any>null;
            if (Array.isArray(_data["transactionRows"])) {
                this.transactionRows = [] as any;
                for (let item of _data["transactionRows"])
                    this.transactionRows!.push(TransactionRowsUpdateRequest.fromJS(item));
            }
            else {
                this.transactionRows = <any>null;
            }
        }
    }

    static fromJS(data: any): TransactionsUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionsUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toFormat('yyyy-MM-dd') : <any>null;
        data["counterpartyId"] = this.counterpartyId !== undefined ? this.counterpartyId : <any>null;
        if (Array.isArray(this.transactionRows)) {
            data["transactionRows"] = [];
            for (let item of this.transactionRows)
                data["transactionRows"].push(item.toJSON());
        }
        return data;
    }
}

/** The request to update an existing transaction */
export interface ITransactionsUpdateRequest {
    /** The date of the transaction */
    date: DateTime;
    /** The id of the counterparty of the transaction */
    counterpartyId: string;
    /** The rows of the transaction */
    transactionRows: TransactionRowsUpdateRequest[];
}

/** The row of a transaction create request */
export class TransactionRowsUpdateRequest implements ITransactionRowsUpdateRequest {
    /** The id of the transaction row */
    id!: string | null;
    /** The progressive number of the transaction row in the scope of the transaction */
    rowCounter!: number;
    /** The id of the account */
    accountId!: string;
    /** The debit amount of the transaction row */
    debit!: number | null;
    /** The credit amount of the transaction row */
    credit!: number | null;
    /** The description of the transaction row */
    description!: string | null;

    constructor(data?: ITransactionRowsUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.rowCounter = _data["rowCounter"] !== undefined ? _data["rowCounter"] : <any>null;
            this.accountId = _data["accountId"] !== undefined ? _data["accountId"] : <any>null;
            this.debit = _data["debit"] !== undefined ? _data["debit"] : <any>null;
            this.credit = _data["credit"] !== undefined ? _data["credit"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
        }
    }

    static fromJS(data: any): TransactionRowsUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionRowsUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["rowCounter"] = this.rowCounter !== undefined ? this.rowCounter : <any>null;
        data["accountId"] = this.accountId !== undefined ? this.accountId : <any>null;
        data["debit"] = this.debit !== undefined ? this.debit : <any>null;
        data["credit"] = this.credit !== undefined ? this.credit : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data;
    }
}

/** The row of a transaction create request */
export interface ITransactionRowsUpdateRequest {
    /** The id of the transaction row */
    id: string | null;
    /** The progressive number of the transaction row in the scope of the transaction */
    rowCounter: number;
    /** The id of the account */
    accountId: string;
    /** The debit amount of the transaction row */
    debit: number | null;
    /** The credit amount of the transaction row */
    credit: number | null;
    /** The description of the transaction row */
    description: string | null;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}

/* eslint-disable */
// noinspection ES6UnusedImports

/**
 * This file is needed for the automatic generation of the models of the backend API.
 * The generation is done via the NSwag toolchain, and the backend project is already
 * configured to generate the file "BackendClient.ts" on every successful build of the project.
 * Everything written in this file will be injected in the generated code by NSwag.
 */