import { AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * This abstract class is inherited by the BackendClient to configure the
 * baseURL of the API client-side.
 * Since the BackendClient file is automatically generated by NSwag, and we can't
 * modify its source because it would get deleted on every rebuild, we can use
 * this class to specify additional logic that needs to be performed when
 * instantiating the API clients.
 */
export default abstract class ServiceBase {
  /**
   * Gets the base URL that will be used by the inherited class to call the API.
   * @param input This input is ignored.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  protected getBaseUrl(input: string): string {
    return import.meta.env.VITE_APP_BACKEND_API_URI;
  }

  /**
   * Manipulates the request configuration before sending it to the API.
   * @param request The request object that will be sent
   */
  protected async transformOptions(request: AxiosRequestConfig) {
    return new Promise<AxiosRequestConfig<unknown>>((resolve) => {
      resolve(request);
    });
  }

  /* eslint-disable @typescript-eslint/no-explicit-any */
  protected async transformResult(
    url: string,
    response: AxiosResponse | XMLHttpRequest,
    processor: (response: AxiosResponse) => Promise<any>,
  ): Promise<any> {
    /* eslint-enable @typescript-eslint/no-explicit-any */
    this.handleApiErrors(url, response);

    return processor(response as AxiosResponse);
  }

  protected handleApiErrors(
    url: string,
    response: AxiosResponse | XMLHttpRequest,
  ) {
    if (response instanceof XMLHttpRequest) {
      alert("Generic network error");
      throw new Error("Generic network error");
    }

    if (response.status >= 200 && response.status <= 299) {
      return;
    }

    let errorMessage = "";

    errorMessage += `Error ${response.status}\n`;

    switch (response.status) {
      case 400:
        if (response.data) {
          if ("errors" in response.data) {
            const errors = (
              response.data as { errors: Record<string, string[]> }
            ).errors;

            const entries = Object.entries(errors);

            for (const [key, value] of entries) {
              errorMessage += ` - ${key}: ${value.join(", ")}\n`;
            }
          } else {
            errorMessage += response.data;
          }
        } else {
          errorMessage += "Bad request";
        }
        break;
      case 401:
        errorMessage += "Authentication error or user not signed in";
        break;
      case 403:
        errorMessage += "Insufficient permissions";
        break;
      case 404:
        errorMessage += "Resource not found";
        break;
      case 500:
        errorMessage += "Server error";
        break;
      default:
        errorMessage += "Unknown error";
        break;
    }

    if (errorMessage) {
      alert(errorMessage);
      throw new Error(errorMessage);
    }

    return;
  }
}
